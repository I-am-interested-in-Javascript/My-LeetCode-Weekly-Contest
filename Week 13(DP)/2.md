# Link to Question
https://leetcode.com/problems/decode-ways/

## Question Summary

## My solution summary

길이가 1인 경우는 일단 바로 걸러내자. s="1", s="0" 이런애들은 금방이다. 연달아 0이 있는 경우도 무조건 답이 없어서 걸러내야한다. 
```javascript
    if(s.length === 1){
        if(s === '0'){
            return 0;
        }else{
            return 1;
        }
    }
    
    for(let i = 0; i < s.length - 1; i++){
        if(s.substring(i, 2) === '00'){
            return 0;
        }
    }
```

dp는 삽질을 해봤는데 잘모르겠어서 재귀호출로 풀어보려고 한다. 되지만 범위가 너무커서 무조건 dynamic programming으로 해결해야하긴한다. 


## My code
1. 망한 코드 1
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    if(s.length === 1){
        if(s === '0'){
            return 0;
        }else{
            return 1;
        }
    }
    
//     const dict = {
//         "1": 'A',
//         "2": 'B',
//         "3": 'C',
//         "4": 'D',
//         "5": 'E',
//         "6": 'F',
//         "7": 'G',
//         "8": 'H',
//         "9": "I",
//         "10": "J",
//         "11": "K",
//         "12": "L",
//         "13": "M",
//         "14": "N",
//         "15": "O",
//         "16": "P",
//         "17": "Q",
//         "18": "R",
//         "19": "S",
//         "20": "T",
//         "21": "U",
//         "22": "V",
//         "23": "W",
//         "24": "X",
//         "25": "Y",
//         "26": "Z"
//     }
    
    
    const d = [...Array(s.length + 1).fill(0)];
    d[0] = 1;
    
    if(s[1] === '0' && s[0] === '0'){
            return 0; // 연달아 0이 있으면 답이 없음
    }else if(s[1] === '0'){
        // 현재 값이 0이면 그전의 값과 합쳐서 비교해야함
        if(parseInt(s.substring(0, 2)) <= 26) {
            d[1] = 1; // 38 이런거면 0인거
        }
    }else if(s[0] === '0'){
        // 지금것만 비교해야함
        d[1] = 1; // 어차피 한자리 수
    }else{
        // 둘다 가능
        d[1] = 1;
        if(parseInt(s.substring(0, 2)) <= 26) {
            d[1] += 1; // 26 이하여야 체크를 경우가 됨
        }
    }
    
    for(let i = 2; i < s.length; i++){
        if(s[i] === '0' && s[i-1] === '0'){
            return 0; // 연달아 0이 있으면 답이 없음
        }else if(s[i] === '0'){
            // 현재 값이 0이면 그전의 값과 합쳐서 비교해야함
            if(parseInt(s.substring(i-1, 2)) <= 26) {
                d[i] = d[i-2]; // 38 이런거면 0인거
            }
        }else if(s[i-1] === '0'){
            // 지금것만 비교해야함
            d[i] = d[i-1]; // 어차피 한자리 수
        }else{
            // 둘다 가능
            d[i] = d[i-1];
            if(parseInt(s.substring(i-1, 2)) <= 26) {
                d[i] += d[i-2]; // 26 이하여야 체크를 경우가 됨
            }
        }
        // console.log(d[i])
    }
    
    return d[s.length-1];
};
```

2. 망한 코드 2(재귀 한거, 범위가 넘 커서 망함)
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    if(s.length === 1){
        if(s === '0'){
            return 0;
        }else{
            return 1;
        }
    }
    
    for(let i = 0; i < s.length - 1; i++){
        if(s.substring(i, 2) === '00'){
            return 0;
        }
    }
        
    let answer = 0;
    
    //     const dict = {
    //     "1": 'A',
    //     "2": 'B',
    //     "3": 'C',
    //     "4": 'D',
    //     "5": 'E',
    //     "6": 'F',
    //     "7": 'G',
    //     "8": 'H',
    //     "9": "I",
    //     "10": "J",
    //     "11": "K",
    //     "12": "L",
    //     "13": "M",
    //     "14": "N",
    //     "15": "O",
    //     "16": "P",
    //     "17": "Q",
    //     "18": "R",
    //     "19": "S",
    //     "20": "T",
    //     "21": "U",
    //     "22": "V",
    //     "23": "W",
    //     "24": "X",
    //     "25": "Y",
    //     "26": "Z"
    // }
    
    function recursive(next){
        // console.log("recursive", next, accum)
        
        if(s[next] === '0'){
            return;
        }
        
        if(next >= s.length){
            answer++;
            return;
        }
           
        if(s[next] !== '0'){
            // 한글자
            // console.log("first", next, accum, s[next]); 
            recursive(next+1);
        }
        
        // 두글자 
        // console.log("next", next, s.substring(next, next+2))
        if(s[next] !== '0' && next + 1 < s.length && parseInt(s.substring(next, next+2)) <= 26) {
            recursive(next+2);
        }    
    }
    
    recursive(0);
    
    
    return answer;
};

```